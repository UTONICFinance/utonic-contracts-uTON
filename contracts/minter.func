#include "imports/stdlib.fc";
#include "libs/utils.func";
#include "common/errors.func";
#include "common/params.func";
#include "common/events.func";
#include "jetton/op.func";
#include "wallet/op.func";
#include "wallet/params.func";
#include "withdraw/op.func";
#include "withdraw/params.func";
#include "proxy/proxy_whale/op.func";
#include "proxy/proxy_whale/params.func";
#include "proxy/proxy_whale/utils.func";
#include "minter/op.func";
#include "minter/params.func";
#include "minter/errors.func";
#include "minter/storage.func";

global int total_supply; 
global int last_price_day;
global int last_price;
global int price_inc;
global int debt_ton;
global slice admin_address;
global slice ton_receiver_address;
global slice uton_receiver_address;
global cell proxy_ordinary_whitelist;
global cell content;
global cell jetton_wallet_code;
global cell withdraw_code;
global cell proxy_whale_code;

() load_global_data() impure inline {
    (total_supply, 
    last_price_day,
    last_price,
    price_inc,
    debt_ton,
    admin_address,
    ton_receiver_address,
    uton_receiver_address,
    proxy_ordinary_whitelist,
    content,
    jetton_wallet_code,
    withdraw_code,
    proxy_whale_code) = load_data();
}

() save_global_data() impure inline {
    save_data(
        total_supply,
        last_price_day,
        last_price,
        price_inc,
        debt_ton,
        admin_address,
        ton_receiver_address,
        uton_receiver_address,
        proxy_ordinary_whitelist,
        content,
        jetton_wallet_code,
        withdraw_code,
        proxy_whale_code
    );
}

(int) get_day(int timestamp) inline {
  return timestamp / ONE_DAY;
}

(int) get_current_day() inline {
    return get_day(now());
}

(int) get_price(int last_price_day, int last_price, int price_inc, int current_day) inline {
  return last_price + (current_day - last_price_day) * price_inc;
}

(int) get_ton_amount(int uton_amount, int price) inline {
    return uton_amount * price / PRICE_BASE;
}

(int) get_uton_amount(int ton_amount, int price) inline {
    return ton_amount * PRICE_BASE / price;
}

() mint_tokens(int query_id, slice user_address, slice response_address, int uton_amount, int msg_value) impure {
    ;; then mint token for user
    var master_msg = begin_cell()
        .store_uint(MINT, 32)
        .store_uint(query_id, 64) 
        .store_coins(uton_amount)
        .store_slice(response_address) 
        ;; .store_coins(0) 
        .store_uint(0, 1)
    .end_cell();

    cell state_init = calculate_jetton_wallet_state_init(user_address, my_address(), jetton_wallet_code);
    slice to_wallet_address = calculate_jetton_wallet_address(state_init);
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to_wallet_address)
        .store_coins(msg_value)
        .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
        .store_ref(state_init)
        .store_ref(master_msg);
    send_raw_message(msg.end_cell(), 0);
}

() stake(int query_id, slice user_address, int msg_value) impure {

    load_global_data();
    int ton_amount = msg_value - MINT_FEE - PROCESS_MINT_FEE;
    throw_unless(INVALID_AMOUNT, ton_amount > 0);
    ;; first send ton to ton_receiver
    var msg_to_ton_receiver = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(ton_receiver_address)
        .store_coins(ton_amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(STAKE_SAVE, 32)
        .store_uint(query_id, 64);
    send_raw_message(msg_to_ton_receiver.end_cell(), 1);

    ;; calculate token amount
    int timestamp = now();
    int today = get_day(timestamp);
    int price = get_price(last_price_day, last_price, price_inc, today);
    int uton_amount = get_uton_amount(ton_amount, price);
    throw_unless(INVALID_UTON_AMOUNT, uton_amount > 0);

    mint_tokens(query_id, user_address, user_address, uton_amount, MINT_FEE);
    total_supply += uton_amount;
    save_global_data();
    slice none_address = begin_cell().store_uint(0, 2).end_cell().begin_parse();
    emit_stake_log(user_address, 255, none_address, ton_amount, uton_amount, price, timestamp);
}

() proxy_whale_stake(int query_id, slice sender_address, int msg_value, slice in_msg_body) impure {
   
    throw_unless(INSUFFICIENT_VALUE, msg_value > MINT_FEE + PROCESS_MINT_FEE);
    load_global_data();

    int ton_amount = in_msg_body~load_coins();
    throw_unless(INVALID_AMOUNT, ton_amount > 0);

    slice user_address = in_msg_body~load_msg_addr();
    slice nominator_pool = in_msg_body~load_msg_addr();
    throw_unless(NOT_ENABLED, equal_slices(calculate_user_proxy_whale_address(user_address, my_address(), nominator_pool, proxy_whale_code), sender_address));
    slice response_address = in_msg_body~load_msg_addr();
    
    ;; calculate token amount
    int timestamp = now();
    int today = get_day(timestamp);
    int price = get_price(last_price_day, last_price, price_inc, today);
    int uton_amount = get_uton_amount(ton_amount, price);
    throw_unless(INVALID_UTON_AMOUNT, uton_amount > 0);

    total_supply += uton_amount; 
    save_global_data();   

    mint_tokens(query_id, uton_receiver_address, response_address, uton_amount, msg_value - PROCESS_MINT_FEE);
    emit_stake_log(user_address, 0, sender_address, ton_amount, uton_amount, price, timestamp);
}

() proxy_ordinary_stake(int query_id, int proxy_type, slice sender_address, int msg_value, slice in_msg_body) impure {
   
    throw_unless(INSUFFICIENT_VALUE, msg_value > MINT_FEE + PROCESS_MINT_FEE);

    load_global_data();
    throw_if(EMPTY_ORDINARY_PROXY_WHITELIST, proxy_ordinary_whitelist.dict_empty?());
    (slice type_address, int has_type) = proxy_ordinary_whitelist.udict_get?(PROXY_WHITE_LIST_KEY_LEN, proxy_type);
    throw_unless(INVALID_ORDINARY_PROXY_TYPE, has_type);
    throw_unless(INVALID_ORDINARY_PROXY, equal_slices(sender_address, type_address));
    int pay_token_amount = in_msg_body~load_coins();
    int uton_amount = in_msg_body~load_coins();
    throw_unless(INVALID_UTON_AMOUNT, uton_amount > 0);
    int price = in_msg_body~load_uint(64);
    slice user_address = in_msg_body~load_msg_addr();
    int timestamp = in_msg_body~load_uint(64);
    slice response_address = in_msg_body~load_msg_addr();

    total_supply += uton_amount; 
    save_global_data();   

    mint_tokens(query_id, user_address, response_address, uton_amount, msg_value - PROCESS_MINT_FEE);
    emit_stake_log(user_address, proxy_type, sender_address, pay_token_amount, uton_amount, price, timestamp);
}


() proxy_stake(int query_id, slice sender_address, int msg_value, slice in_msg_body) impure {
    int proxy_type = in_msg_body~load_uint(PROXY_WHITE_LIST_KEY_LEN);
    if (proxy_type == 0) {
        ;; large proxy
        proxy_whale_stake(query_id,sender_address,msg_value,in_msg_body);
    } else {
        ;; ordinary user proxy
        proxy_ordinary_stake(query_id,proxy_type,sender_address,msg_value,in_msg_body);
    }
}


() _pending_withdraw(
    slice user_address, 
    int withdraw_id, 
    cell withdraw_code,
    cell master_msg,
    int msg_value) impure {

    cell state_init = calculate_withdraw_state_init(
        withdraw_id, user_address, my_address(), withdraw_code
    );
    slice withdraw_address = calculate_withdraw_address(state_init);
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(withdraw_address)
        .store_coins(msg_value)
        .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
        .store_ref(state_init)
        .store_ref(master_msg);
    send_raw_message(msg.end_cell(), 0);
}

() burn(int query_id, slice sender_address, int msg_value, slice in_msg_body) impure {

    throw_unless(INSUFFICIENT_VALUE, msg_value >= PROCESS_BURN_FEE + WITHDRAW_INIT_FEE);
    load_global_data();

    int uton_amount = in_msg_body~load_coins();
    slice user_address = in_msg_body~load_msg_addr();
    int withdraw_id = in_msg_body~load_uint(64);
    slice response_address = in_msg_body~load_msg_addr();
    ;; check wallet address
    throw_unless(WRONG_CALLER, equal_slices(calculate_user_jetton_wallet_address(user_address, my_address(), jetton_wallet_code), sender_address));

    ;; calculate ton amount
    int timestamp = now();

    int today = get_day(timestamp);
    int price = get_price(last_price_day, last_price, price_inc, today);
    int ton_amount = get_ton_amount(uton_amount, price);

    ;; reduce supply
    total_supply -= uton_amount;
    debt_ton += ton_amount;
    save_global_data();

    ;; create a pending withdraw for user
    var master_msg = begin_cell()
        .store_uint(INIT_WITHDRAW_DATA, 32)
        .store_uint(query_id, 64) 
        .store_coins(uton_amount)
        .store_coins(ton_amount)
        .store_uint(timestamp, 64)
        .store_uint(price, 64)
        .store_slice(response_address) 
        ;; .store_coins(0) 
        .store_uint(0, 1)
    .end_cell();

    _pending_withdraw(
        user_address, 
        withdraw_id, 
        withdraw_code,
        master_msg,
        msg_value - PROCESS_BURN_FEE
    );
    emit_burn_log(user_address, withdraw_id, uton_amount, ton_amount, price, timestamp);
}

() proxy_whale_burn(int query_id, slice sender_address, int msg_value, slice in_msg_body) impure {
    
    throw_unless(INSUFFICIENT_VALUE, msg_value >= PROCESS_PROXY_WHALE_BURN_FEE + PROXY_WHALE_ADD_WITHDRAW_CAPACITY_FEE);
    load_global_data();

    int uton_amount = in_msg_body~load_coins();
    slice from_address = in_msg_body~load_msg_addr();
    slice proxy_address = in_msg_body~load_msg_addr();
    slice response_address = in_msg_body~load_msg_addr();
    ;; check wallet address
    throw_unless(WRONG_CALLER, equal_slices(calculate_user_jetton_wallet_address(from_address, my_address(), jetton_wallet_code), sender_address));

    ;; calculate ton amount
    int timestamp = now();
    int today = get_day(timestamp);
    int price = get_price(last_price_day, last_price, price_inc, today);
    int ton_amount = get_ton_amount(uton_amount, price);
    ;; reduce supply
    total_supply -= uton_amount;
    save_global_data();
    ;; send to proxy
    var msg_body = begin_cell()
        .store_uint(ADD_WITHDRAW_CAPACITY, 32)
        .store_uint(query_id, 64)
        .store_coins(ton_amount)
        .store_slice(response_address) 
        ;; .store_coins(0) 
        .store_uint(0, 1)
    .end_cell();

    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(proxy_address)
        ;; todo determine msg value for burn notification
        .store_coins(msg_value - PROCESS_PROXY_WHALE_BURN_FEE)
        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(msg_body);
    send_raw_message(msg.end_cell(), 0);

    emit_burn_for_whale_log(from_address, proxy_address, uton_amount, ton_amount, price, timestamp);
}

() withdraw(int query_id, slice sender_address, slice in_msg_body, int my_ton_balance, int msg_value) impure {
    
    load_global_data();

    throw_unless(INSUFFICIENT_VALUE, msg_value >= PROCESS_WITHDRAW_FEE);

    int ton_amount = in_msg_body~load_coins();
    slice user_address = in_msg_body~load_msg_addr();
    slice recipient_address = in_msg_body~load_msg_addr();
    int withdraw_id = in_msg_body~load_uint(64);
    int balance_before_msg = my_ton_balance - msg_value;
    
    throw_unless(INSUFFICIENT_BALANCE, balance_before_msg - ton_amount >= MINIMAL_RESERVE);
    throw_unless(WRONG_CALLER, equal_slices(calculate_user_withdraw_address(user_address, withdraw_id, my_address(), withdraw_code), sender_address));
    
    debt_ton -= ton_amount;
    save_global_data();

    var msg_withdraw_fund = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(recipient_address)
        .store_coins(ton_amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(WITHDRAW_FUND, 32)
        .store_uint(query_id, 64);
    send_raw_message(msg_withdraw_fund.end_cell(), 2 + 1);

    slice response_address = in_msg_body~load_msg_addr();
    msg_value -= PROCESS_WITHDRAW_FEE;
    if ((response_address.preload_uint(2) != 0) & (msg_value > 0)) {
        var msg_excesses = begin_cell()
            .store_uint(0x10, 6)
            .store_slice(response_address)
            .store_coins(msg_value)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(EXCESSES, 32)
            .store_uint(query_id, 64);
        send_raw_message(msg_excesses.end_cell(), 2);
    }

    emit_withdraw_log(user_address, withdraw_id, ton_amount, recipient_address, now());
}

() update_proxy_whale_whitelist(int query_id, slice sender_address, int msg_value, slice in_msg_body) impure {

    load_global_data();
    throw_unless(UNAUTHORIZED, equal_slices(sender_address, admin_address));

    slice response_address = in_msg_body~load_msg_addr();
    int enable = in_msg_body~load_uint(1);
    int proxy_num = in_msg_body~load_uint(32);

    throw_unless(INSUFFICIENT_VALUE, msg_value >= (PROXY_WHALE_ENABLE_SWITCH_FEE + PROCESS_SET_WHITE_LIST_LOOP_FEE) * proxy_num + PROCESS_SET_WHITE_LIST_BASE_FEE);

    var msg_body = begin_cell()
        .store_uint(ENABLE_SWITCH, 32)
        .store_uint(query_id, 64)
        .store_uint(enable, 1)
        .store_slice(response_address) 
        ;; .store_coins(0) 
        .store_uint(0, 1)
    .end_cell();

    cell whale_proxies_dict = in_msg_body~load_dict();
    (int current_key, slice current_proxy_whale, int finish_flag) = whale_proxies_dict.udict_get_min?(8);
    int idx = 0;
    while (finish_flag & idx < proxy_num) {
        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(current_proxy_whale)
            ;; todo determine msg value for burn notification
            .store_coins(PROXY_WHALE_ENABLE_SWITCH_FEE)
            .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_ref(msg_body);
        send_raw_message(msg.end_cell(), 0);
        (current_key, current_proxy_whale, finish_flag) = whale_proxies_dict.udict_get_next?(8, current_key);
        idx += 1;
    }
    save_global_data();
}


() update_proxy_ordinary_whitelist(int query_id, slice sender_address, int msg_value, slice in_msg_body) impure {

    load_global_data();
    throw_unless(UNAUTHORIZED, equal_slices(sender_address, admin_address));

    int proxy_type = in_msg_body~load_uint(PROXY_WHITE_LIST_KEY_LEN);
    proxy_ordinary_whitelist.udict_delete?(PROXY_WHITE_LIST_KEY_LEN,proxy_type);
    slice address = in_msg_body~load_msg_addr();
    if (address.preload_uint(2) != 0) {
        proxy_ordinary_whitelist.udict_set(PROXY_WHITE_LIST_KEY_LEN,proxy_type,address);
    }
    save_global_data();
}


() recv_internal(int balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { 
        return ();
    }
    slice sender_address = cs~load_msg_addr();
    cs~load_msg_addr();
    cs~load_coins();
    cs~skip_bits(1);
    cs~load_coins();
    int fwd_fee = cs~load_coins();

    if (in_msg_body.slice_empty?()) {
        ;; just deposit
        return ();
    }

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    if (op == STAKE) {
        stake(query_id, sender_address, msg_value);
        return ();
    }

    if (op == DEPOSIT_NOTIFICATION) {
        proxy_stake(query_id, sender_address, msg_value, in_msg_body);
        return ();
    }

    if (op == BURN_NOTIFICATION) {
        burn(query_id, sender_address, msg_value, in_msg_body);
        return ();
    }

    if (op == PROXY_WHALE_BURN_NOTIFICATION) {
        proxy_whale_burn(query_id, sender_address, msg_value, in_msg_body);
        return ();
    }

    if (op == WITHDRAW_NOTIFICATION) {
        withdraw(query_id, sender_address, in_msg_body, balance, msg_value);
        return ();
    }

    ;; admin operate

    if (op == UPDATE_ADMIN) {
        load_global_data();
        throw_unless(UNAUTHORIZED, equal_slices(sender_address, admin_address));
        slice new_admin_address = in_msg_body~load_msg_addr();
        admin_address = new_admin_address;
        save_global_data();
        return ();
    }

    if (op == UPDATE_PRICE) {
        load_global_data();
        throw_unless(UNAUTHORIZED, equal_slices(sender_address, admin_address));

        int new_price = in_msg_body~load_uint(64);
        int new_price_inc = in_msg_body~load_uint(64);
        int today = get_current_day();        
        last_price_day = today;
        last_price = new_price;
        price_inc = new_price_inc;
        save_global_data();
        return ();
    }

    if (op == UPDATE_PRICE_INC) {
        load_global_data();
        throw_unless(UNAUTHORIZED, equal_slices(sender_address, admin_address));
        
        int new_price_inc = in_msg_body~load_uint(64);
        int today = get_current_day();
        int price = get_price(last_price_day, last_price, price_inc, today);
        last_price_day = today;
        last_price = price;
        price_inc = new_price_inc;
        save_global_data();
        return ();
    }

    if (op == UPDATE_CONTENT) {
        load_global_data();
        throw_unless(UNAUTHORIZED, equal_slices(sender_address, admin_address));
        content = in_msg_body~load_ref();
        save_global_data();
        return ();
    }

    if (op == UPDATE_PROXY_WHALE_WHITELIST) {
        update_proxy_whale_whitelist(query_id, sender_address, msg_value, in_msg_body);
        return ();
    }

    if (op == UPDATE_ORDINARY_PROXY_WHITELIST) {
        update_proxy_ordinary_whitelist(query_id, sender_address, msg_value, in_msg_body);
        return ();
    }

    if (op == UPDATE_CODE_AND_DATA) {
        throw_unless(UNAUTHORIZED, equal_slices(sender_address, admin_address));
        cell code = in_msg_body~load_ref();
        cell data = in_msg_body~load_ref();
        ifnot (code.cell_null?()) {
            set_code(code);
        }
        ifnot (data.cell_null?()) {
            set_data(data);
        }
        return ();
    }

    if (op == UPDATE_TON_RECEIVER) {
        load_global_data();
        throw_unless(UNAUTHORIZED, equal_slices(sender_address, admin_address));
        ton_receiver_address = in_msg_body~load_msg_addr();
        save_global_data();
        return ();
    }

    if (op == UPDATE_UTON_RECEIVER) {
        load_global_data();
        throw_unless(UNAUTHORIZED, equal_slices(sender_address, admin_address));
        uton_receiver_address = in_msg_body~load_msg_addr();
        save_global_data();
        return ();
    }

    throw(0xffff);

}

(int, int, int, int, int, slice, slice, slice, cell, cell, cell, cell, cell) get_minter_data() method_id {
    load_global_data();
    return (total_supply, last_price_day, last_price, price_inc, debt_ton, admin_address, ton_receiver_address, uton_receiver_address, proxy_ordinary_whitelist, content, jetton_wallet_code, withdraw_code, proxy_whale_code);
}

slice get_proxy_whale_address(slice owner_address, slice nominator_pool) method_id {
    (_, _, _, _, _, _, _, _, _, _, _, _, cell proxy_whale_code) = load_data();
    return calculate_user_proxy_whale_address(owner_address, my_address(), nominator_pool, proxy_whale_code);
}

slice get_wallet_address(slice owner_address) method_id {
    (_, _, _, _, _, _, _, _, _, _, cell jetton_wallet_code, _, _) = load_data();
    return calculate_user_jetton_wallet_address(owner_address, my_address(), jetton_wallet_code);
}

slice get_withdraw_address(slice owner_address, int withdraw_id) method_id {
    (_, _, _, _, _, _, _, _, _, _, _, cell withdraw_code, _) = load_data();
    return calculate_user_withdraw_address(owner_address, withdraw_id, my_address(), withdraw_code);
}

;; _ supported_interfaces() method_id {
;;     return (
;;         123515602279859691144772641439386770278, ;; org.ton.introspection.v0
;;         242422353946785872806511191513850808027 ;; org.ton.jetton.master.v1
;;     );
;; }