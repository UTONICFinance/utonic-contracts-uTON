#include "imports/stdlib.fc";
#include "libs/utils.func";
#include "common/errors.func";
#include "jetton/op.func";
#include "minter/op.func";
#include "minter/params.func";
#include "withdraw/op.func";
#include "withdraw/params.func";
#include "proxy/proxy_whale/params.func";
#include "wallet/op.func";
#include "wallet/params.func";
#include "wallet/storage.func";

global int balance;
global int withdraw_cnt;
global slice owner_address;
global slice jetton_master_address;
global cell jetton_wallet_code;

() load_global_data() impure inline {
    (
        balance, 
        withdraw_cnt, 
        owner_address, 
        jetton_master_address, 
        jetton_wallet_code
    ) = load_data();
}

() save_global_data() impure inline {
    save_data(
        balance, 
        withdraw_cnt, 
        owner_address, 
        jetton_master_address, 
        jetton_wallet_code
    );
}


() send_tokens (slice in_msg_body, slice sender_address, int msg_value, int fwd_fee) impure {
    int query_id = in_msg_body~load_uint(64);
    int uton_amount = in_msg_body~load_coins();
    slice to_owner_address = in_msg_body~load_msg_addr();
    force_chain(WORKCHAIN, to_owner_address, 704);

    load_global_data();
    balance -= uton_amount;
    throw_unless(705, equal_slices(owner_address, sender_address));
    throw_unless(706, balance >= 0);

    cell state_init = calculate_jetton_wallet_state_init(to_owner_address, jetton_master_address, jetton_wallet_code);
    slice to_wallet_address = calculate_jetton_wallet_address(state_init);
    slice response_address = in_msg_body~load_msg_addr();
    cell custom_payload = in_msg_body~load_dict();
    int forward_ton_amount = in_msg_body~load_coins();
    slice either_forward_payload = in_msg_body;
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to_wallet_address)
        .store_coins(0)
        .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
        .store_ref(state_init);
    var msg_body = begin_cell()
        .store_uint(INTERNAL_TRANSFER, 32)
        .store_uint(query_id, 64)
        .store_coins(uton_amount)
        .store_slice(owner_address)
        .store_slice(response_address)
        .store_coins(forward_ton_amount)
        .store_slice(either_forward_payload)
        .end_cell();

    msg = msg.store_ref(msg_body);
    int fwd_count = forward_ton_amount ? 2 : 1;
    throw_unless(709, msg_value > forward_ton_amount + fwd_count * fwd_fee + WALLET_SEND_FEE + WALLET_RECEIVE_FEE + WALLET_MIN_TON_STORAGE);

    save_global_data();
    ;; send INTERNAL_TRANSFER, msg-64
    send_raw_message(msg.end_cell(), 64); ;; revert on errors
}

() mint_tokens (slice in_msg_body, slice sender_address, int my_ton_balance, int fwd_fee, int msg_value) impure {
    load_global_data();
    
    int query_id = in_msg_body~load_uint(64);
    int uton_amount = in_msg_body~load_coins();
    balance += uton_amount;

    save_global_data();

    slice response_address = in_msg_body~load_msg_addr();
    throw_unless(707, equal_slices(jetton_master_address, sender_address));

    int ton_balance_before_msg = my_ton_balance - msg_value;
    int storage_fee = WALLET_MIN_TON_STORAGE - min(ton_balance_before_msg, WALLET_MIN_TON_STORAGE);
    msg_value -= (storage_fee + WALLET_MINT_FEE);

    if ((response_address.preload_uint(2) != 0) & (msg_value > 0)) {
        var msg = begin_cell()
            .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
            .store_slice(response_address)
            .store_coins(msg_value)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(EXCESSES, 32)
            .store_uint(query_id, 64);
        send_raw_message(msg.end_cell(), 2);
    }
}

() receive_tokens (slice in_msg_body, slice sender_address, int my_ton_balance, int fwd_fee, int msg_value) impure {
    load_global_data();

    int query_id = in_msg_body~load_uint(64);
    int uton_amount = in_msg_body~load_coins();
    balance += uton_amount;

    slice from_address = in_msg_body~load_msg_addr();
    slice response_address = in_msg_body~load_msg_addr();
    throw_unless(707, equal_slices(calculate_user_jetton_wallet_address(from_address, jetton_master_address, jetton_wallet_code), sender_address));
    int forward_ton_amount = in_msg_body~load_coins();

    int ton_balance_before_msg = my_ton_balance - msg_value;
    int storage_fee = WALLET_MIN_TON_STORAGE - min(ton_balance_before_msg, WALLET_MIN_TON_STORAGE);
    msg_value -= (storage_fee + WALLET_RECEIVE_FEE);
    if(forward_ton_amount) {
        msg_value -= (forward_ton_amount + fwd_fee);
        slice either_forward_payload = in_msg_body;

        var msg_body = begin_cell()
            .store_uint(TRANSFER_NOTIFICATION, 32)
            .store_uint(query_id, 64)
            .store_coins(uton_amount)
            .store_slice(from_address)
            .store_slice(either_forward_payload)
            .end_cell();

        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(owner_address)
            .store_coins(forward_ton_amount)
            .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_ref(msg_body);

        send_raw_message(msg.end_cell(), 1);
    }

    if ((response_address.preload_uint(2) != 0) & (msg_value > 0)) {
        var msg = begin_cell()
            .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
            .store_slice(response_address)
            .store_coins(msg_value)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(EXCESSES, 32)
            .store_uint(query_id, 64);
        send_raw_message(msg.end_cell(), 2);
    }

    save_global_data();
}

() burn_tokens (slice in_msg_body, slice sender_address, int msg_value, int fwd_fee) impure {
    
    load_global_data();

    int query_id = in_msg_body~load_uint(64);
    int uton_amount = in_msg_body~load_coins();
    slice response_address = in_msg_body~load_msg_addr();
    int withdraw_id = withdraw_cnt;
    withdraw_cnt += 1;
    balance -= uton_amount;

    throw_unless(705, equal_slices(owner_address, sender_address));
    throw_unless(706, balance >= 0);
    throw_unless(707, msg_value > 2 * fwd_fee + WALLET_BURN_FEE + PROCESS_BURN_FEE + WITHDRAW_INIT_FEE);

    save_global_data();

    var msg_body = begin_cell()
        .store_uint(BURN_NOTIFICATION, 32)
        .store_uint(query_id, 64)
        .store_coins(uton_amount)
        .store_slice(owner_address)
        .store_uint(withdraw_id, 64)
        .store_slice(response_address)
        .end_cell();

    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(jetton_master_address)
        ;; todo determine msg value for burn notification
        .store_coins(0)
        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(msg_body);
    ;; send BURN_NOTIFICATION, msg-64
    send_raw_message(msg.end_cell(), 64);

}


() proxy_whale_burn_tokens (slice in_msg_body, slice sender_address, int msg_value, int fwd_fee) impure {
    load_global_data();

    int query_id = in_msg_body~load_uint(64);
    int uton_amount = in_msg_body~load_coins();
    slice proxy_address = in_msg_body~load_msg_addr();
    slice response_address = in_msg_body~load_msg_addr();
    
    balance -= uton_amount;
    throw_unless(705, equal_slices(owner_address, sender_address));
    throw_unless(706, balance >= 0);
    throw_unless(707, msg_value > 2 * fwd_fee + WALLET_PROXY_WHALE_BURN_FEE + PROCESS_PROXY_WHALE_BURN_FEE + PROXY_WHALE_ADD_WITHDRAW_CAPACITY_FEE);
    save_global_data();

    var msg_body = begin_cell()
        .store_uint(PROXY_WHALE_BURN_NOTIFICATION, 32)
        .store_uint(query_id, 64)
        .store_coins(uton_amount)
        .store_slice(owner_address)
        .store_slice(proxy_address)
        .store_slice(response_address)
        .end_cell();

    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(jetton_master_address)
        ;; todo determine msg value for burn notification
        .store_coins(0)
        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(msg_body);
    ;; send PROXY_WHALE_BURN_NOTIFICATION, msg-64
    send_raw_message(msg.end_cell(), 64);
}


() on_bounce (slice in_msg_body) impure {
    in_msg_body~skip_bits(32); ;; 0xFFFFFFFF
    load_global_data();
    int op = in_msg_body~load_uint(32);
    throw_unless(709, (op == INTERNAL_TRANSFER) | (op == BURN_NOTIFICATION));
    int query_id = in_msg_body~load_uint(64);
    int uton_amount = in_msg_body~load_coins();
    balance += uton_amount;
    ;; cannot reduce withdraw_cnt back
    save_global_data();
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        on_bounce(in_msg_body);
        return ();
    }
    slice sender_address = cs~load_msg_addr();
    cs~load_msg_addr();
    cs~load_coins();
    cs~skip_bits(1);
    cs~load_coins();
    int fwd_fee = cs~load_coins();

    int op = in_msg_body~load_uint(32);

    if (op == TRANSFER) { 
        send_tokens(in_msg_body, sender_address, msg_value, fwd_fee);
        return ();
    }

    if (op == INTERNAL_TRANSFER) {
        receive_tokens(in_msg_body, sender_address, my_balance, fwd_fee, msg_value);
        return ();
    }

    if (op == MINT) {
        mint_tokens(in_msg_body, sender_address, my_balance, fwd_fee, msg_value);
        return ();
    }

    if (op == BURN) {
        burn_tokens(in_msg_body, sender_address, msg_value, fwd_fee);
        return ();
    }

    if (op == PROXY_WHALE_BURN) {
        proxy_whale_burn_tokens(in_msg_body, sender_address, msg_value, fwd_fee);
        return ();
    }

    throw(0xffff);
}

(int, int, slice, slice, cell) get_wallet_data() method_id {
    load_global_data();
    return (
        balance, 
        withdraw_cnt,
        owner_address, 
        jetton_master_address, 
        jetton_wallet_code
    );
}
